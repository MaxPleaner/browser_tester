- commands = Db.transaction { Db[:commands] }
- modules = Db.transaction { Db[:modules] }


div.blackbox

  button toggles="#create-command" create command

  form.bordered#create-command.hidden action='/create_command' method="POST"
    
    ul
      li
        i
         | the 
         a href='https://github.com/jnicklas/capybara' capybara 
         | api is available as top-level methods
      li
        i
         | for example, a command to open a url is 
         code visit 'http://google.com'
      li
        i more broadly, though, a command can contain arbitrary ruby code.

    b name: 
    br
    input type='text' name='name' placeholder='name'
    br
    br
    b command:
    br
    br
    textarea name='command' placeholder='# ruby code'
    br
    br
    input type='submit' value='save'
  br

hr.cool-hr

div.blackbox

  div#modules
    
    button toggles='#create-module' create module
    form.bordered#create-module.hidden action='/new_module' method="POST"
      br
      b name:
      br
      br
      input type='text' name='name' placeholder='name'
      br
      br
      input type='submit' value='save'
    br

    hr.cool-hr
    
    - if modules.keys.any?
      br
      button toggles="#modules-list" modules list
      br
      br
      ul
        li
          i drag command into a module
        li
          i commands can be dragged between modules and re-sorted
        li
          i 
            | if you export a module to lib, you can import it in a script using 'module_require'
            br
            | for example, if the module was saved with a master filename of 'my_file.rb'
            br
            | then in a command you could say module_require 'my_file'
      div.blackbox#modules-list.bordered.clearfix
        - modules.each do |module_id, module_obj|
          div class=("#{module_id} module tooltip") data-id=module_id
            button toggles=(".#{module_id}.module-commands") = module_obj[:name]
            br
            div class=("#{module_id} module-commands")
              ul.sortable-module-command-list
                - (module_obj[:commands] || []).each_with_index do |command_id, idx|
                  - module_command = commands[command_id]
                  li.module-command data-id=command_id data-name=module_command[:name]
                    b = module_command[:name]
                    br
                    button class='remove-module-command' remove command
                    br
              br
              form.run-module action='run_module' method="POST"
                input type='hidden' name='id' value=module_id
                i the number of seconds to pause between commands:
                br
                input type='number' name='interval' value='2'
                br
                input type='submit' value='run'
              br
              form.export-module action='export_module' method="POST"
                input type='hidden' name='id' value=module_id
                input type='text' name='name' placeholder='master filename'
                br
                input type='submit' value='export to lib'
              br
              form.delete-module action='delete_module' method="POST"
                input type='hidden' name='id' value=module_id
                input type='submit' value='delete'

      div.clearfix
      hr.cool-hr

div.clearfix
- if commands.keys.any?
  div.blackbox
    button toggles="#commands-list" commands list
  div.blackbox#commands-list.bordered
  
    - commands.each do |id, command|
      div class=("#{id} command") data-id=id
        p = command[:name]
        br
        button toggles=(".#{id}.command-body") show content
        br
        pre class=("#{id} command-body hidden") = command[:command]
        br

        div.inlinebox
          form.delete action='/delete_command' method='POST'
            input type='hidden' name='id' value=id
            input type='submit' value='delete'
      
        div.inlinebox
          button toggles=(".#{id} [action='update_command']") edit
      
        div.inlinebox
          form action='run_command' method='POST'
            input type='hidden' name='id' value=id
            input type='submit' value='run'
  
        form.hidden action='update_command' method='POST'
          br
          input type='hidden' name='id' value=id
          b name
          br 
          input type='text' name='name' value=command[:name]
          br
          b command: 
          br
          textarea name='command'
            - if command[:command]&.length > 0
              = command[:command]
          br
          input type='submit' value='update'
  hr.cool-hr

pre.hidden#log

- if @results
  div.blackbox
    == @results

- if @err
  div.blackbox
    == @err

coffee:

  syncModule = (moduleId, commandIds, callback) ->
    $.post("/sync_module_commands", {
      moduleId: moduleId
      commandIds: commandIds.join ","
    }, callback)

  syncAllModules = (callback) ->
    modules = $.map $(".module"), (el, idx) ->
      $module = $ el
      id: $module.data "id"
      commandIds: commandIdsForModule($module)
    $.post("/sync_all_modules", {
      modules: modules
    }, callback)


  commandIdsForModule = ($module) ->
    # the ids are stored in the data-id attribute of .module-command nodes
    # but $(".module-command").data("id") will not show an accurate list
    # if some of the ids are duplicate
    $.map $module.find(".module-command"), (el) -> $(el).data "id"

  dragAndDrop = (selector) ->
    $(selector).draggable
      cursor: 'move'

    $(".module").droppable
      over: (e, ui) ->
        $(e.target).addClass("drop-destination-hover")
      out: (e, ui) ->
        $(e.target).removeClass("drop-destination-hover")
      drop: (e, ui) ->
        $module = $(e.target)
        moduleId = $module.data("id")
        ids = commandIdsForModule($module)
        $command = $(e.originalEvent.toElement)
        if $command.hasClass("module-command")
          return false # proceed - it's a sort event
        else if ! $command.hasClass "command"
          # this is a kind of wierd situation: when text inside a draggable
          # is dragged, then only the text shows up as dragged and not the
          # parent container
          $command = $command.parents(".command")
        commandId = $command.data "id"
        ids.push commandId
        syncModule moduleId, ids, ->
          window.location.reload()

    $(".remove-module-command").off("click").on "click", (e) ->
      $moduleCommand = $(e.currentTarget).parents(".module-command")
      $module = $moduleCommand.parents(".module")
      $moduleCommand.remove()
      moduleId = $module.data "id"
      commandIds = commandIdsForModule($module)
      syncModule moduleId, commandIds, ->
        window.location.reload()

  sortableModuleCommands = (selector) ->
    $(selector).sortable
      connectWith: selector
      stop: ->
        syncAllModules(->)
      dropOnEmpty: true 

  runModuleAjax = ->
    $( ".run-module" ).off("submit").on  "submit", (e) ->
      e.preventDefault()
      $form = $(e.currentTarget)
      data = $form.serialize()
      # the response to this $post is discarded
      # instead, the server sends log info over websockets
      $.post $form.attr("action"), data
      false

  ChangeUrl = (page, url) ->
    if typeof(history.pushState) != 'undefined'
      obj =
        Page: page
        Url: url
      history.pushState obj, obj.Page, obj.Url


  $(->
    ChangeUrl("", "/")
    console.log "doc ready"
    window.helpers = new SocketHelpers()
    window.ws = helpers.ws
    initToggling()
    $(".delete, .delete-module").off("submit").on "submit", (e) -> confirmSubmit e
    dragAndDrop(".command")
    sortableModuleCommands(".sortable-module-command-list")
    runModuleAjax()
  )
